#!/usr/bin/env node

import dotenv from 'dotenv';
import { Telegraf } from 'telegraf';
import axios from 'axios';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import OpenAI from 'openai';

// Get __dirname equivalent in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

dotenv.config();

// Configuration
const TELEGRAM_TOKEN = process.env.TELEGRAM_TOKEN;
const OPENAI_KEY = process.env.OPENAI_KEY;
const API_URL = 'http://localhost:3001/api'; // Web app backend URL

// Initialize bot and OpenAI
const bot = new Telegraf(TELEGRAM_TOKEN);
const openai = new OpenAI({
    apiKey: OPENAI_KEY,
});

// Helper function to transcribe audio
async function transcribeAudio(filePath) {
    try {
        const audioFile = await fs.readFile(filePath);
        const transcription = await openai.audio.transcriptions.create({
            file: new File([audioFile], path.basename(filePath), { type: 'audio/ogg' }),
            model: 'whisper-1',
            language: 'ru'
        });
        
        return transcription.text;
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏:', error);
        throw error;
    }
}

// Generate title from content using AI
async function generateTitle(content) {
    try {
        const completion = await openai.chat.completions.create({
            model: 'gpt-4o-mini',
            messages: [
                {
                    role: 'system',
                    content: '–°–æ–∑–¥–∞–π –∫—Ä–∞—Ç–∫–∏–π –∑–∞–≥–æ–ª–æ–≤–æ–∫ (2-4 —Å–ª–æ–≤–∞) –¥–ª—è –∑–∞–º–µ—Ç–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—è. –û—Ç–≤–µ—Ç—å —Ç–æ–ª—å–∫–æ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º, –±–µ–∑ –ª–∏—à–Ω–∏—Ö —Å–ª–æ–≤.'
                },
                {
                    role: 'user',
                    content: content
                }
            ],
            temperature: 0.7,
            max_tokens: 20
        });
        
        return completion.choices[0].message.content.trim();
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞:', error);
        return '–ì–æ–ª–æ—Å–æ–≤–∞—è –∑–∞–º–µ—Ç–∫–∞';
    }
}

// Save note to database
async function saveNoteToDatabase(title, content, type = 'voice') {
    try {
        const response = await axios.post(`${API_URL}/notes`, {
            title,
            content,
            type,
            date: new Date().toISOString(),
            // Don't send x,y - let backend calculate position automatically
            tags: []
        }, {
            headers: {
                'user-id': 'test-user-id', // Same as web app to show on same canvas
                'Content-Type': 'application/json'
            }
        });
        
        return response.data;
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –ë–î:', error);
        throw error;
    }
}

// Handle voice messages
bot.on('voice', async (ctx) => {
    const userId = ctx.from.id;
    const voiceFileId = ctx.message.voice.file_id;
    
    // Send initial message
    const processingMsg = await ctx.reply('‚è≥ –ù–∞—á–∏–Ω–∞—é –æ–±—Ä–∞–±–æ—Ç–∫—É –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è...');
    
    try {
        // Download voice file
        const fileLink = await ctx.telegram.getFileLink(voiceFileId);
        const response = await axios.get(fileLink.href, { responseType: 'arraybuffer' });
        const buffer = Buffer.from(response.data);
        
        // Save to temporary file
        const tempPath = path.join(__dirname, `temp_${Date.now()}.ogg`);
        await fs.writeFile(tempPath, buffer);
        
        // Transcribe audio
        const transcription = await transcribeAudio(tempPath);
        
        // Clean up temp file
        await fs.unlink(tempPath).catch(console.error);
        
        if (!transcription || transcription.trim().length === 0) {
            await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id);
            await ctx.reply('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ');
            return;
        }
        
        // Generate title
        const title = await generateTitle(transcription);
        
        // Save to database
        await saveNoteToDatabase(title, transcription, 'voice');
        
        // Delete processing message
        await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id);
        
        // Send success message as reply to original voice
        await ctx.reply(
            `‚úÖ –ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ\n\nüìù *${title}*\n${transcription.substring(0, 200)}${transcription.length > 200 ? '...' : ''}`,
            {
                reply_to_message_id: ctx.message.message_id,
                parse_mode: 'Markdown'
            }
        );
        
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
        
        // Delete processing message
        await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id).catch(() => {});
        
        await ctx.reply('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è', {
            reply_to_message_id: ctx.message.message_id
        });
    }
});

// Handle start command
bot.start((ctx) => {
    ctx.reply(
        'üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∑–∞–º–µ—Ç–æ–∫.\n\n' +
        'üìù –ß—Ç–æ —è —É–º–µ—é:\n' +
        '‚Ä¢ üé§ –ì–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è - —Ä–∞—Å—à–∏—Ñ—Ä—É—é –∏ —Å–æ—Ö—Ä–∞–Ω—é\n' +
        '‚Ä¢ üìÑ –¢–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è - —Å–æ—Ö—Ä–∞–Ω—é –∫–∞–∫ –µ—Å—Ç—å\n' +
        '‚Ä¢ üéµ –ê—É–¥–∏–æ —Ñ–∞–π–ª—ã (MP3) - —Ä–∞—Å—à–∏—Ñ—Ä—É—é –∏ —Å–æ—Ö—Ä–∞–Ω—é\n' +
        '‚Ä¢ üé¨ –í–∏–¥–µ–æ —Ñ–∞–π–ª—ã (MP4) - –∏–∑–≤–ª–µ–∫—É –∑–≤—É–∫ –∏ —Ä–∞—Å—à–∏—Ñ—Ä—É—é\n\n' +
        '–í—Å–µ –∑–∞–º–µ—Ç–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.\n' +
        '–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ –ª—é–±–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ!'
    );
});

// Handle audio files (MP3, etc)
bot.on('audio', async (ctx) => {
    const audioFileId = ctx.message.audio.file_id;
    const processingMsg = await ctx.reply('‚è≥ –ù–∞—á–∏–Ω–∞—é –æ–±—Ä–∞–±–æ—Ç–∫—É –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞...');
    
    try {
        // Download audio file
        const fileLink = await ctx.telegram.getFileLink(audioFileId);
        const response = await axios.get(fileLink.href, { responseType: 'arraybuffer' });
        const buffer = Buffer.from(response.data);
        
        // Save to temporary file
        const tempPath = path.join(__dirname, `temp_audio_${Date.now()}.mp3`);
        await fs.writeFile(tempPath, buffer);
        
        // Transcribe audio
        const transcription = await transcribeAudio(tempPath);
        
        // Clean up temp file
        await fs.unlink(tempPath).catch(console.error);
        
        if (!transcription || transcription.trim().length === 0) {
            await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id);
            await ctx.reply('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –∞—É–¥–∏–æ —Ñ–∞–π–ª');
            return;
        }
        
        // Generate title
        const title = await generateTitle(transcription);
        
        // Save to database
        await saveNoteToDatabase(title, transcription, 'voice');
        
        // Delete processing message
        await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id);
        
        // Send success message
        await ctx.reply(
            `‚úÖ –ê—É–¥–∏–æ —Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω –∏ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ\n\nüìù *${title}*\n${transcription.substring(0, 200)}${transcription.length > 200 ? '...' : ''}`,
            {
                reply_to_message_id: ctx.message.message_id,
                parse_mode: 'Markdown'
            }
        );
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞:', error);
        await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id).catch(() => {});
        await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞', {
            reply_to_message_id: ctx.message.message_id
        });
    }
});

// Handle video files (MP4, etc) - extract audio and transcribe
bot.on('video', async (ctx) => {
    const videoFileId = ctx.message.video.file_id;
    const processingMsg = await ctx.reply('‚è≥ –ù–∞—á–∏–Ω–∞—é –æ–±—Ä–∞–±–æ—Ç–∫—É –≤–∏–¥–µ–æ —Ñ–∞–π–ª–∞...');
    
    try {
        // Download video file
        const fileLink = await ctx.telegram.getFileLink(videoFileId);
        const response = await axios.get(fileLink.href, { responseType: 'arraybuffer' });
        const buffer = Buffer.from(response.data);
        
        // Save to temporary file
        const tempPath = path.join(__dirname, `temp_video_${Date.now()}.mp4`);
        await fs.writeFile(tempPath, buffer);
        
        // Try to transcribe directly (Whisper can handle video files)
        const transcription = await transcribeAudio(tempPath);
        
        // Clean up temp file
        await fs.unlink(tempPath).catch(console.error);
        
        if (!transcription || transcription.trim().length === 0) {
            await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id);
            await ctx.reply('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å –∞—É–¥–∏–æ –∏–∑ –≤–∏–¥–µ–æ —Ñ–∞–π–ª–∞');
            return;
        }
        
        // Generate title
        const title = await generateTitle(transcription);
        
        // Save to database
        await saveNoteToDatabase(title, transcription, 'voice');
        
        // Delete processing message
        await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id);
        
        // Send success message
        await ctx.reply(
            `‚úÖ –í–∏–¥–µ–æ —Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω –∏ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ\n\nüìù *${title}*\n${transcription.substring(0, 200)}${transcription.length > 200 ? '...' : ''}`,
            {
                reply_to_message_id: ctx.message.message_id,
                parse_mode: 'Markdown'
            }
        );
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∏–¥–µ–æ —Ñ–∞–π–ª–∞:', error);
        await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id).catch(() => {});
        await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª–∞', {
            reply_to_message_id: ctx.message.message_id
        });
    }
});

// Handle text messages - save directly to database
bot.on('text', async (ctx) => {
    const text = ctx.message.text;
    
    // Skip commands
    if (text.startsWith('/')) return;
    
    try {
        // Generate title from first 50 chars or first line
        const firstLine = text.split('\n')[0];
        const title = firstLine.length > 50 
            ? firstLine.substring(0, 47) + '...' 
            : firstLine;
        
        // Save to database
        await saveNoteToDatabase(title, text, 'text');
        
        // Send confirmation
        await ctx.reply(
            `‚úÖ –¢–µ–∫—Å—Ç–æ–≤–∞—è –∑–∞–º–µ—Ç–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ\n\nüìù *${title}*`,
            {
                reply_to_message_id: ctx.message.message_id,
                parse_mode: 'Markdown'
            }
        );
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–æ–≤–æ–π –∑–∞–º–µ—Ç–∫–∏:', error);
        await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∑–∞–º–µ—Ç–∫–∏', {
            reply_to_message_id: ctx.message.message_id
        });
    }
});

// Launch bot
bot.launch()
    .then(() => {
        console.log('‚úÖ Telegram –±–æ—Ç –∑–∞–ø—É—â–µ–Ω');
        console.log('üìù –ü–æ–¥–¥–µ—Ä–∂–∫–∞: –≥–æ–ª–æ—Å–æ–≤—ã–µ, —Ç–µ–∫—Å—Ç, MP3, MP4');
        console.log('üíæ –í—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ –µ–¥–∏–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ');
    })
    .catch(error => {
        console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞:', error);
    });

// Enable graceful stop
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));