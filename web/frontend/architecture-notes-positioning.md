# Как работает позиционирование заметок на canvas
!учти что дока зедсь написана человеческим языком чтоб была понятная всем разрабам, а не просто страничка в википедии
## Общая идея

Представь, что у тебя есть заметки за разные даты - какие-то за вчера, какие-то за месяц назад, какие-то за 3 месяца назад. Вместо того чтобы показывать календарь с кучей пустых дней между ними, мы показываем только те дни, где реально есть заметки. Это как если бы в твоем дневнике были только страницы с записями, а пустые страницы просто выкинули.

## Техническая архитектура

### Что приходит с backend

Backend отдает ВСЕ заметки что есть в базе, без ограничений по времени. Каждая заметка имеет дату с полным временем, типа `2025-07-28T12:12:00.000Z`. Это важно - у нас нет нормализации дат на бэке, каждая заметка хранит точное время создания.

### Магия с позиционированием

Когда заметки приходят на frontend, мы делаем следующее:

1. **Собираем уникальные даты** - проходимся по всем заметкам и собираем список дат
2. **Сортируем их** - от старых к новым
3. **Находим "сегодня"** - ищем в этом списке сегодняшний день (или ближайший будущий)
4. **Создаем мапу** - каждой дате присваиваем индекс относительно сегодня

Например, если у нас есть заметки за 10 июля, 5 августа и 20 августа (сегодня), то мапа будет:
```
{
  '2025-07-10T12:12:00.000Z': -2,  // третья колонка слева
  '2025-08-05T00:00:00.000Z': -1,  // вторая колонка слева
  '2025-08-20T00:00:00.000Z': 0    // центральная колонка (сегодня)
}
```

### Проблема с React State (и как мы её решили)

Тут была хитрая проблема. Когда мы делаем `setDateColumnMap(mapping)`, React не обновляет состояние мгновенно. Он откладывает это до следующего цикла рендеринга. А нам нужно сразу создать shapes на canvas с правильными позициями.

**Старый подход (не работал):**
1. Загрузили заметки
2. Создали мапу и положили в state
3. Сразу вызвали createShapesFromNotes
4. Функция смотрит в dateColumnMap... а он еще пустой! React не успел обновить

**Новый подход (работает):**
1. Загрузили заметки
2. Создали мапу
3. Вернули из loadNotes сразу `{ notes: [...], dateMap: {...} }`
4. Передали мапу напрямую в createShapesFromNotes как параметр
5. State обновится потом, для будущих операций

Это как если бы ты не ждал пока курьер доставит посылку на склад, а забрал её прямо из его рук.

### Вычисление X координаты

У нас есть константа: сегодня всегда на X = 5000px. Это центр нашего мира.

Каждая колонка занимает 230px ширины. Формула простая:
```
X = 5000 + (индекс_колонки × 230)
```

Если индекс -2 (две колонки левее от сегодня):
```
X = 5000 + (-2 × 230) = 5000 - 460 = 4540px
```

### Два режима позиционирования

У каждой заметки есть флаг `manuallyPositioned`:

- **false** (по умолчанию) - заметка в колонке своей даты, X считается через мапу
- **true** - пользователь вручную переместил заметку, используем сохраненные X и Y

Это позволяет перетаскивать заметки куда угодно, но новые всегда появляются в правильной колонке.

### Заголовки дат

Заголовки (те самые "10 АВГ", "20 АВГ") генерируются из той же мапы дат. Поэтому они всегда совпадают с колонками заметок. Нет ситуации когда заголовок есть, а заметок под ним нет.

При первой загрузке мы создаем заголовки вручную прямо в handleMount, используя ту же мапу что передали в createShapesFromNotes. Это гарантирует что всё появится одновременно.

### Почему setTimeout на 100ms?

Это не для React state! Это для tldraw. Canvas должен полностью инициализироваться прежде чем мы начнем создавать shapes. Без этой задержки shapes могут просто не появиться. Это особенность работы с canvas-based библиотеками.

## Итоговый flow

1. **Пользователь открывает приложение**
2. **loadNotes()** тянет все заметки с backend
3. **Создается dateColumnMap** - индексы для каждой уникальной даты
4. **Возвращается** `{ notes, dateMap }` - данные + метаданные
5. **setTimeout 100ms** - ждем пока tldraw проинициализируется
6. **Генерируем заголовки** из dateMap
7. **createShapesFromNotes** получает dateMap напрямую и создает заметки
8. **React обновляет state** для будущих операций (drag & drop, новые заметки)

## Почему это круто

- **Масштабируется** - хоть миллион заметок за 10 лет, всё будет работать
- **Компактно** - нет пустых колонок между заметками
- **Быстро** - O(1) lookup позиции через hash-таблицу вместо вычислений дат
- **Гибко** - легко добавить группировку по неделям/месяцам в будущем

## Потенциальные проблемы

- **Память** - держим ВСЕ заметки в DOM, может тормозить при тысячах заметок
- **Даты с временем** - если у одной даты разное время, они считаются разными колонками
- **Часовые пояса** - не учитываем timezone, всё в UTC

## Если хочешь что-то поменять

- Ширина колонок: константа 230 в calculateColumnX и createShapesFromNotes
- Центр мира: константа 5000 (TODAY_X)
- Логика группировки: меняй как создается dateColumnMap в loadNotes
- Добавить виртуализацию: придется переписывать createShapesFromNotes чтобы создавать только видимые shapes