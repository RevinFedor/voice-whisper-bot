import { Injectable } from '@nestjs/common';
import axios from 'axios';
import { PrismaService } from '../prisma/prisma.service';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

@Injectable()
export class ObsidianService {
  private readonly baseUrl: string;
  private readonly apiKey: string;
  private readonly defaultFolder: string;

  constructor(private prisma: PrismaService) {
    if (!process.env.OBSIDIAN_HOST) throw new Error('OBSIDIAN_HOST is required in environment variables');
    if (!process.env.OBSIDIAN_PORT) throw new Error('OBSIDIAN_PORT is required in environment variables');
    if (!process.env.OBSIDIAN_API_KEY) throw new Error('OBSIDIAN_API_KEY is required in environment variables');
    if (!process.env.OBSIDIAN_FOLDER) throw new Error('OBSIDIAN_FOLDER is required in environment variables');
    
    const host = process.env.OBSIDIAN_HOST;
    const port = process.env.OBSIDIAN_PORT;
    this.baseUrl = `http://${host}:${port}`;
    this.apiKey = process.env.OBSIDIAN_API_KEY;
    this.defaultFolder = process.env.OBSIDIAN_FOLDER;
  }

  async getAllTags(): Promise<string[]> {
    try {
      // Get all files with tags using search
      const response = await axios.post(
        `${this.baseUrl}/search/`,
        {
          '!=': [{ var: 'tags' }, []],
        },
        {
          headers: {
            Authorization: `Bearer ${this.apiKey}`,
            'Content-Type': 'application/vnd.olrapi.jsonlogic+json',
          },
        }
      );

      const allTags = new Set<string>();

      // For each file, get its metadata
      if (response.data && Array.isArray(response.data)) {
        
        // Process all files
        for (const item of response.data) {
          if (item.filename && item.filename.endsWith('.md')) {
            try {
              const fileResponse = await axios.get(
                `${this.baseUrl}/vault/${encodeURIComponent(item.filename)}`,
                {
                  headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                    Accept: 'application/json',
                  },
                }
              );

              // –ï—Å–ª–∏ data —ç—Ç–æ —Å—Ç—Ä–æ–∫–∞, –∑–Ω–∞—á–∏—Ç API –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ –∫–æ–Ω—Ç–µ–Ω—Ç
              // –ù—É–∂–Ω–æ –∏—Å–∫–∞—Ç—å —Ç–µ–≥–∏ –≤ frontmatter –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥—Ä—É–≥–æ–π endpoint
              if (typeof fileResponse.data === 'string') {
                // –ü–æ–ø—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å —Ç–µ–≥–∏ –∏–∑ frontmatter
                const frontmatterMatch = fileResponse.data.match(/^---\n([\s\S]*?)\n---/);
                if (frontmatterMatch) {
                  const frontmatter = frontmatterMatch[1];
                  
                  // –î–≤–∞ —Ñ–æ—Ä–º–∞—Ç–∞: tags: [tag1, tag2] –∏–ª–∏ tags:\n  - tag1\n  - tag2
                  // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º —Ñ–æ—Ä–º–∞—Ç —Å–ø–∏—Å–∫–∞ YAML
                  const yamlListMatch = frontmatter.match(/tags:\s*\n((?:\s*-\s*.+\n?)+)/);
                  if (yamlListMatch) {
                    const tagsList = yamlListMatch[1];
                    const tags = tagsList.match(/-\s*(.+)/g)?.map(t => t.replace(/-\s*/, '').trim()) || [];
                    tags.forEach(tag => {
                      if (tag && tag !== 'tg-transcript') {
                        allTags.add(tag);
                      }
                    });
                  } else {
                    // –ü—Ä–æ–±—É–µ–º —Ñ–æ—Ä–º–∞—Ç inline [tag1, tag2]
                    const inlineMatch = frontmatter.match(/tags:\s*\[(.*?)\]/);
                    if (inlineMatch) {
                      const tagsString = inlineMatch[1];
                      const tags = tagsString.split(',').map(t => t.trim().replace(/['"]/g, ''));
                      tags.forEach(tag => {
                        if (tag && tag !== 'tg-transcript') {
                          allTags.add(tag);
                        }
                      });
                    }
                  }
                }
              } else if (fileResponse.data && fileResponse.data.tags) {
                fileResponse.data.tags.forEach((tag: string) => {
                  if (tag && tag !== 'tg-transcript') {
                    allTags.add(tag);
                  }
                });
              }
            } catch (e) {
              // Skip files with errors silently
            }
          }
        }
      }

      const result = Array.from(allTags).sort();
      return result;
    } catch (error) {
      // Return empty array if Obsidian is not available
      console.log('‚ö†Ô∏è [Obsidian] –ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ —Ç–µ–≥–æ–≤');
      return [];
    }
  }

  async exportNote(noteId: string, folder?: string): Promise<{
    success: boolean;
    filepath?: string;
    vaultName?: string;
    obsidianUrl?: string;
    error?: string;
  }> {
    try {
      // –ü–æ–ª—É—á–∞–µ–º –∑–∞–º–µ—Ç–∫—É –∏–∑ –ë–î
      const note = await this.prisma.note.findUnique({
        where: { id: noteId },
      });

      if (!note) {
        throw new Error('Note not found');
      }

      // –§–æ—Ä–º–∏—Ä—É–µ–º –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É
      const targetFolder = folder || this.defaultFolder;
      // Sanitize filename - —É–¥–∞–ª—è–µ–º –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã –¥–ª—è –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
      let sanitizedTitle = note.title
        .replace(/[\/\\:*?"<>|]/g, '') // –£–¥–∞–ª—è–µ–º –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã
        .replace(/\s+/g, ' ') // –ó–∞–º–µ–Ω—è–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã –Ω–∞ –æ–¥–∏–Ω
        .trim();
      
      // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ (252 —Å–∏–º–≤–æ–ª–∞ –º–∞–∫—Å–∏–º—É–º –¥–ª—è —É—á–µ—Ç–∞ .md —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è)
      // –¢–∞–∫–∂–µ —É—á–∏—Ç—ã–≤–∞–µ–º –¥–ª–∏–Ω—É –ø—É—Ç–∏ –∫ –ø–∞–ø–∫–µ
      const maxFilenameLength = 200; // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å —É—á–µ—Ç–æ–º –ø—É—Ç–∏
      if (sanitizedTitle.length > maxFilenameLength) {
        sanitizedTitle = sanitizedTitle.substring(0, maxFilenameLength).trim();
        console.log(`   ‚ö†Ô∏è –ò–º—è —Ñ–∞–π–ª–∞ —Å–æ–∫—Ä–∞—â–µ–Ω–æ –¥–æ ${maxFilenameLength} —Å–∏–º–≤–æ–ª–æ–≤`);
      }
      
      const filename = `${sanitizedTitle}.md`;
      const filepath = `${targetFolder}/${filename}`;

      // –§–æ—Ä–º–∏—Ä—É–µ–º frontmatter –¥–ª—è Obsidian
      // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É –≤ –ª–æ–∫–∞–ª—å–Ω–æ–º —á–∞—Å–æ–≤–æ–º –ø–æ—è—Å–µ –≤–º–µ—Å—Ç–æ UTC
      const formatLocalDate = (date: Date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
      };
      
      const dateForDisplay = formatLocalDate(note.date);
      const tags = note.tags?.length > 0 ? note.tags : [];
      
      // –≠–∫—Ä–∞–Ω–∏—Ä—É–µ–º title –¥–ª—è YAML (–∑–∞–∫–ª—é—á–∞–µ–º –≤ –∫–∞–≤—ã—á–∫–∏ –µ—Å–ª–∏ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª—ã)
      const escapedTitle = note.title.includes(':') || note.title.includes('"') || note.title.includes('\n')
        ? `"${note.title.replace(/"/g, '\\"')}"` 
        : note.title;

      // –§–æ—Ä–º–∏—Ä—É–µ–º YAML frontmatter - —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–æ–ª—è
      let frontmatter = `---
title: ${escapedTitle}
date: "${dateForDisplay}"
source: WebApplication`;

      // –î–æ–±–∞–≤–ª—è–µ–º tags —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
      if (tags.length > 0) {
        frontmatter += `\ntags:\n  - ${tags.join('\n  - ')}`;
      }
      // –ï—Å–ª–∏ —Ç–µ–≥–æ–≤ –Ω–µ—Ç - –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–µ tags –≤–æ–æ–±—â–µ

      frontmatter += `\n---`;

      const content = `${frontmatter}

${note.content || ''}`;

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Obsidian
      console.log('üì§ [Obsidian] –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ —ç–∫—Å–ø–æ—Ä—Ç...');
      console.log(`   üîó URL: ${this.baseUrl}/vault/${encodeURIComponent(filepath)}`);
      
      const response = await axios.put(
        `${this.baseUrl}/vault/${encodeURIComponent(filepath)}`,
        content,
        {
          headers: {
            Authorization: `Bearer ${this.apiKey}`,
            'Content-Type': 'text/markdown',
          },
          // –ù–µ –ø—ã—Ç–∞–µ–º—Å—è –ø–∞—Ä—Å–∏—Ç—å –æ—Ç–≤–µ—Ç –∫–∞–∫ JSON, —Ç–∞–∫ –∫–∞–∫ Obsidian –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç
          responseType: 'text',
          // –ü—Ä–∏–Ω–∏–º–∞–µ–º –ª—é–±–æ–π —Å—Ç–∞—Ç—É—Å 2xx –∫–∞–∫ —É—Å–ø–µ—à–Ω—ã–π
          validateStatus: (status) => status >= 200 && status < 300,
        }
      );

      console.log(`   üìä –°—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞: ${response.status}`);
      
      // Obsidian API –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 200 –∏–ª–∏ 204 –ø—Ä–∏ —É—Å–ø–µ—Ö–µ
      if (response.status === 200 || response.status === 204) {
        console.log('‚úÖ [Obsidian] –ó–∞–º–µ—Ç–∫–∞ —É—Å–ø–µ—à–Ω–æ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞');
        console.log(`   üìù –ó–∞–≥–æ–ª–æ–≤–æ–∫: ${note.title}`);
        console.log(`   üìÅ –ü–∞–ø–∫–∞: ${targetFolder}`);
        console.log(`   üè∑Ô∏è –¢–µ–≥–∏: ${tags.length > 0 ? tags.join(', ') : '–Ω–µ—Ç'}`);

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Å–∏—Å—Ç–µ–º–Ω—ã–µ –¥–∞—Ç—ã —Ñ–∞–π–ª–∞
        await this.setFileDates(filepath, note.date, note.updatedAt);

        // –£–¥–∞–ª—è–µ–º –∑–∞–º–µ—Ç–∫—É –∏–∑ –ë–î –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —ç–∫—Å–ø–æ—Ä—Ç–∞
        await this.prisma.note.delete({
          where: { id: noteId },
        });
        console.log('   üóëÔ∏è –ó–∞–º–µ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∞ –∏–∑ –ë–î');

        // –§–æ—Ä–º–∏—Ä—É–µ–º URL –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –≤ Obsidian
        if (!process.env.OBSIDIAN_VAULT_NAME) throw new Error('OBSIDIAN_VAULT_NAME is required in environment variables');
        const vaultName = process.env.OBSIDIAN_VAULT_NAME;
        // –î–ª—è Obsidian URL –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –∏–º—è —Ñ–∞–π–ª–∞, –Ω–µ –ø–æ–ª–Ω—ã–π –ø—É—Ç—å
        const obsidianUrl = `obsidian://open?vault=${encodeURIComponent(vaultName)}&file=${encodeURIComponent(filepath)}`;

        return {
          success: true,
          filepath: targetFolder,
          vaultName,
          obsidianUrl,
        };
      } else {
        throw new Error(`Unexpected status code: ${response.status}`);
      }
    } catch (error) {
      console.error('‚ùå [Obsidian] –û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞:');
      console.error('   –°–æ–æ–±—â–µ–Ω–∏–µ:', error.message);
      if (error.response) {
        console.error('   –°—Ç–∞—Ç—É—Å:', error.response.status);
        console.error('   –î–∞–Ω–Ω—ã–µ:', error.response.data);
      }
      if (error.code) {
        console.error('   –ö–æ–¥ –æ—à–∏–±–∫–∏:', error.code);
      }
      
      // –ë–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
      let errorMessage = 'Failed to export note';
      if (error.code === 'ECONNREFUSED') {
        errorMessage = 'Obsidian API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ Obsidian –∑–∞–ø—É—â–µ–Ω –∏ REST API –∞–∫—Ç–∏–≤–µ–Ω';
      } else if (error.response?.status === 401) {
        errorMessage = '–ù–µ–≤–µ—Ä–Ω—ã–π API –∫–ª—é—á –¥–ª—è Obsidian';
      } else if (error.response?.status === 404) {
        errorMessage = '–ü—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ Obsidian vault';
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      return {
        success: false,
        error: errorMessage,
      };
    }
  }

  /**
   * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–∏—Å—Ç–µ–º–Ω—ã–µ –¥–∞—Ç—ã —Å–æ–∑–¥–∞–Ω–∏—è –∏ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ —Ñ–∞–π–ª–∞
   * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –∫–æ–º–∞–Ω–¥—É SetFile –Ω–∞ macOS
   */
  private async setFileDates(filepath: string, createdDate: Date, modifiedDate: Date): Promise<void> {
    try {
      // –ü–æ–ª—É—á–∞–µ–º –ø—É—Ç—å –∫ vault
      const vaultPath = process.env.OBSIDIAN_VAULT_PATH || '/Users/fedor/Documents/Obsidian Vault';
      const fullPath = `${vaultPath}/${filepath}`;
      
      // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—ã –¥–ª—è SetFile (MM/DD/YYYY HH:MM:SS)
      const formatDate = (date: Date) => {
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const year = date.getFullYear();
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${month}/${day}/${year} ${hours}:${minutes}:${seconds}`;
      };
      
      const createdStr = formatDate(createdDate);
      const modifiedStr = formatDate(modifiedDate);
      
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–∞—Ç—É —Å–æ–∑–¥–∞–Ω–∏—è
      await execAsync(`SetFile -d '${createdStr}' "${fullPath}"`);
      console.log(`   üìÖ –î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: ${createdStr}`);
      
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–∞—Ç—É –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏
      await execAsync(`SetFile -m '${modifiedStr}' "${fullPath}"`);
      console.log(`   üìÖ –î–∞—Ç–∞ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: ${modifiedStr}`);
      
    } catch (error) {
      // –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–∞—è –æ—à–∏–±–∫–∞ - —Ñ–∞–π–ª —Å–æ–∑–¥–∞–Ω, –ø—Ä–æ—Å—Ç–æ –¥–∞—Ç—ã —Å–∏—Å—Ç–µ–º–Ω—ã–µ –Ω–µ –∏–∑–º–µ–Ω–µ–Ω—ã
      console.warn(`   ‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–º–µ–Ω–∏—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–µ –¥–∞—Ç—ã: ${error.message}`);
      console.log(`   ‚ÑπÔ∏è –§–∞–π–ª —Å–æ–∑–¥–∞–Ω —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º frontmatter (created/modified)`);
    }
  }
}